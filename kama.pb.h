// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kama.proto

#ifndef PROTOBUF_kama_2eproto__INCLUDED
#define PROTOBUF_kama_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace kama {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_kama_2eproto();
void protobuf_AssignDesc_kama_2eproto();
void protobuf_ShutdownFile_kama_2eproto();

class Envelope;
class AngleChannelState;
class StateGettingReq;
class StateGettingAck;
class Ping;
class Pong;
class PointingTableSettingReq;
class PointingTableSettingAck;
class PointingTableSettingNak;
class PointingTableGettingReq;
class PointingTableGettingAck;
class CalibrationTableSettingReq;
class CalibrationTableSettingAck;
class CalibrationTableSettingNak;
class CalibrationTableGettingReq;
class CalibrationTableGettingAck;
class PointingTable;
class PointingTableItem;
class CalibrationTable;
class CalibrationTableItem;

// ===================================================================

class Envelope : public ::google::protobuf::Message {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  void Swap(Envelope* other);

  // implements Message ----------------------------------------------

  Envelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kama.protocol.AngleChannelState angle_channel_state = 1;
  inline bool has_angle_channel_state() const;
  inline void clear_angle_channel_state();
  static const int kAngleChannelStateFieldNumber = 1;
  inline const ::kama::protocol::AngleChannelState& angle_channel_state() const;
  inline ::kama::protocol::AngleChannelState* mutable_angle_channel_state();
  inline ::kama::protocol::AngleChannelState* release_angle_channel_state();
  inline void set_allocated_angle_channel_state(::kama::protocol::AngleChannelState* angle_channel_state);

  // optional .kama.protocol.StateGettingReq state_getting_req = 2;
  inline bool has_state_getting_req() const;
  inline void clear_state_getting_req();
  static const int kStateGettingReqFieldNumber = 2;
  inline const ::kama::protocol::StateGettingReq& state_getting_req() const;
  inline ::kama::protocol::StateGettingReq* mutable_state_getting_req();
  inline ::kama::protocol::StateGettingReq* release_state_getting_req();
  inline void set_allocated_state_getting_req(::kama::protocol::StateGettingReq* state_getting_req);

  // optional .kama.protocol.StateGettingAck state_getting_ack = 3;
  inline bool has_state_getting_ack() const;
  inline void clear_state_getting_ack();
  static const int kStateGettingAckFieldNumber = 3;
  inline const ::kama::protocol::StateGettingAck& state_getting_ack() const;
  inline ::kama::protocol::StateGettingAck* mutable_state_getting_ack();
  inline ::kama::protocol::StateGettingAck* release_state_getting_ack();
  inline void set_allocated_state_getting_ack(::kama::protocol::StateGettingAck* state_getting_ack);

  // optional .kama.protocol.PointingTableSettingReq pointing_table_setting_req = 4;
  inline bool has_pointing_table_setting_req() const;
  inline void clear_pointing_table_setting_req();
  static const int kPointingTableSettingReqFieldNumber = 4;
  inline const ::kama::protocol::PointingTableSettingReq& pointing_table_setting_req() const;
  inline ::kama::protocol::PointingTableSettingReq* mutable_pointing_table_setting_req();
  inline ::kama::protocol::PointingTableSettingReq* release_pointing_table_setting_req();
  inline void set_allocated_pointing_table_setting_req(::kama::protocol::PointingTableSettingReq* pointing_table_setting_req);

  // optional .kama.protocol.PointingTableSettingAck pointing_table_setting_ack = 5;
  inline bool has_pointing_table_setting_ack() const;
  inline void clear_pointing_table_setting_ack();
  static const int kPointingTableSettingAckFieldNumber = 5;
  inline const ::kama::protocol::PointingTableSettingAck& pointing_table_setting_ack() const;
  inline ::kama::protocol::PointingTableSettingAck* mutable_pointing_table_setting_ack();
  inline ::kama::protocol::PointingTableSettingAck* release_pointing_table_setting_ack();
  inline void set_allocated_pointing_table_setting_ack(::kama::protocol::PointingTableSettingAck* pointing_table_setting_ack);

  // optional .kama.protocol.PointingTableSettingNak pointing_table_setting_nak = 6;
  inline bool has_pointing_table_setting_nak() const;
  inline void clear_pointing_table_setting_nak();
  static const int kPointingTableSettingNakFieldNumber = 6;
  inline const ::kama::protocol::PointingTableSettingNak& pointing_table_setting_nak() const;
  inline ::kama::protocol::PointingTableSettingNak* mutable_pointing_table_setting_nak();
  inline ::kama::protocol::PointingTableSettingNak* release_pointing_table_setting_nak();
  inline void set_allocated_pointing_table_setting_nak(::kama::protocol::PointingTableSettingNak* pointing_table_setting_nak);

  // optional .kama.protocol.PointingTableGettingReq pointing_table_getting_req = 7;
  inline bool has_pointing_table_getting_req() const;
  inline void clear_pointing_table_getting_req();
  static const int kPointingTableGettingReqFieldNumber = 7;
  inline const ::kama::protocol::PointingTableGettingReq& pointing_table_getting_req() const;
  inline ::kama::protocol::PointingTableGettingReq* mutable_pointing_table_getting_req();
  inline ::kama::protocol::PointingTableGettingReq* release_pointing_table_getting_req();
  inline void set_allocated_pointing_table_getting_req(::kama::protocol::PointingTableGettingReq* pointing_table_getting_req);

  // optional .kama.protocol.PointingTableGettingAck pointing_table_getting_ack = 8;
  inline bool has_pointing_table_getting_ack() const;
  inline void clear_pointing_table_getting_ack();
  static const int kPointingTableGettingAckFieldNumber = 8;
  inline const ::kama::protocol::PointingTableGettingAck& pointing_table_getting_ack() const;
  inline ::kama::protocol::PointingTableGettingAck* mutable_pointing_table_getting_ack();
  inline ::kama::protocol::PointingTableGettingAck* release_pointing_table_getting_ack();
  inline void set_allocated_pointing_table_getting_ack(::kama::protocol::PointingTableGettingAck* pointing_table_getting_ack);

  // optional .kama.protocol.CalibrationTableSettingReq calibration_table_setting_req = 9;
  inline bool has_calibration_table_setting_req() const;
  inline void clear_calibration_table_setting_req();
  static const int kCalibrationTableSettingReqFieldNumber = 9;
  inline const ::kama::protocol::CalibrationTableSettingReq& calibration_table_setting_req() const;
  inline ::kama::protocol::CalibrationTableSettingReq* mutable_calibration_table_setting_req();
  inline ::kama::protocol::CalibrationTableSettingReq* release_calibration_table_setting_req();
  inline void set_allocated_calibration_table_setting_req(::kama::protocol::CalibrationTableSettingReq* calibration_table_setting_req);

  // optional .kama.protocol.CalibrationTableSettingAck calibration_table_setting_ack = 10;
  inline bool has_calibration_table_setting_ack() const;
  inline void clear_calibration_table_setting_ack();
  static const int kCalibrationTableSettingAckFieldNumber = 10;
  inline const ::kama::protocol::CalibrationTableSettingAck& calibration_table_setting_ack() const;
  inline ::kama::protocol::CalibrationTableSettingAck* mutable_calibration_table_setting_ack();
  inline ::kama::protocol::CalibrationTableSettingAck* release_calibration_table_setting_ack();
  inline void set_allocated_calibration_table_setting_ack(::kama::protocol::CalibrationTableSettingAck* calibration_table_setting_ack);

  // optional .kama.protocol.CalibrationTableSettingNak calibration_table_setting_nak = 11;
  inline bool has_calibration_table_setting_nak() const;
  inline void clear_calibration_table_setting_nak();
  static const int kCalibrationTableSettingNakFieldNumber = 11;
  inline const ::kama::protocol::CalibrationTableSettingNak& calibration_table_setting_nak() const;
  inline ::kama::protocol::CalibrationTableSettingNak* mutable_calibration_table_setting_nak();
  inline ::kama::protocol::CalibrationTableSettingNak* release_calibration_table_setting_nak();
  inline void set_allocated_calibration_table_setting_nak(::kama::protocol::CalibrationTableSettingNak* calibration_table_setting_nak);

  // optional .kama.protocol.CalibrationTableGettingReq calibration_table_getting_req = 12;
  inline bool has_calibration_table_getting_req() const;
  inline void clear_calibration_table_getting_req();
  static const int kCalibrationTableGettingReqFieldNumber = 12;
  inline const ::kama::protocol::CalibrationTableGettingReq& calibration_table_getting_req() const;
  inline ::kama::protocol::CalibrationTableGettingReq* mutable_calibration_table_getting_req();
  inline ::kama::protocol::CalibrationTableGettingReq* release_calibration_table_getting_req();
  inline void set_allocated_calibration_table_getting_req(::kama::protocol::CalibrationTableGettingReq* calibration_table_getting_req);

  // optional .kama.protocol.CalibrationTableGettingAck calibration_table_getting_ack = 13;
  inline bool has_calibration_table_getting_ack() const;
  inline void clear_calibration_table_getting_ack();
  static const int kCalibrationTableGettingAckFieldNumber = 13;
  inline const ::kama::protocol::CalibrationTableGettingAck& calibration_table_getting_ack() const;
  inline ::kama::protocol::CalibrationTableGettingAck* mutable_calibration_table_getting_ack();
  inline ::kama::protocol::CalibrationTableGettingAck* release_calibration_table_getting_ack();
  inline void set_allocated_calibration_table_getting_ack(::kama::protocol::CalibrationTableGettingAck* calibration_table_getting_ack);

  // @@protoc_insertion_point(class_scope:kama.protocol.Envelope)
 private:
  inline void set_has_angle_channel_state();
  inline void clear_has_angle_channel_state();
  inline void set_has_state_getting_req();
  inline void clear_has_state_getting_req();
  inline void set_has_state_getting_ack();
  inline void clear_has_state_getting_ack();
  inline void set_has_pointing_table_setting_req();
  inline void clear_has_pointing_table_setting_req();
  inline void set_has_pointing_table_setting_ack();
  inline void clear_has_pointing_table_setting_ack();
  inline void set_has_pointing_table_setting_nak();
  inline void clear_has_pointing_table_setting_nak();
  inline void set_has_pointing_table_getting_req();
  inline void clear_has_pointing_table_getting_req();
  inline void set_has_pointing_table_getting_ack();
  inline void clear_has_pointing_table_getting_ack();
  inline void set_has_calibration_table_setting_req();
  inline void clear_has_calibration_table_setting_req();
  inline void set_has_calibration_table_setting_ack();
  inline void clear_has_calibration_table_setting_ack();
  inline void set_has_calibration_table_setting_nak();
  inline void clear_has_calibration_table_setting_nak();
  inline void set_has_calibration_table_getting_req();
  inline void clear_has_calibration_table_getting_req();
  inline void set_has_calibration_table_getting_ack();
  inline void clear_has_calibration_table_getting_ack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::kama::protocol::AngleChannelState* angle_channel_state_;
  ::kama::protocol::StateGettingReq* state_getting_req_;
  ::kama::protocol::StateGettingAck* state_getting_ack_;
  ::kama::protocol::PointingTableSettingReq* pointing_table_setting_req_;
  ::kama::protocol::PointingTableSettingAck* pointing_table_setting_ack_;
  ::kama::protocol::PointingTableSettingNak* pointing_table_setting_nak_;
  ::kama::protocol::PointingTableGettingReq* pointing_table_getting_req_;
  ::kama::protocol::PointingTableGettingAck* pointing_table_getting_ack_;
  ::kama::protocol::CalibrationTableSettingReq* calibration_table_setting_req_;
  ::kama::protocol::CalibrationTableSettingAck* calibration_table_setting_ack_;
  ::kama::protocol::CalibrationTableSettingNak* calibration_table_setting_nak_;
  ::kama::protocol::CalibrationTableGettingReq* calibration_table_getting_req_;
  ::kama::protocol::CalibrationTableGettingAck* calibration_table_getting_ack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static Envelope* default_instance_;
};
// -------------------------------------------------------------------

class AngleChannelState : public ::google::protobuf::Message {
 public:
  AngleChannelState();
  virtual ~AngleChannelState();

  AngleChannelState(const AngleChannelState& from);

  inline AngleChannelState& operator=(const AngleChannelState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AngleChannelState& default_instance();

  void Swap(AngleChannelState* other);

  // implements Message ----------------------------------------------

  AngleChannelState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AngleChannelState& from);
  void MergeFrom(const AngleChannelState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 time_mode = 1;
  inline bool has_time_mode() const;
  inline void clear_time_mode();
  static const int kTimeModeFieldNumber = 1;
  inline ::google::protobuf::int32 time_mode() const;
  inline void set_time_mode(::google::protobuf::int32 value);

  // required string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // required int32 tracking_mode = 3;
  inline bool has_tracking_mode() const;
  inline void clear_tracking_mode();
  static const int kTrackingModeFieldNumber = 3;
  inline ::google::protobuf::int32 tracking_mode() const;
  inline void set_tracking_mode(::google::protobuf::int32 value);

  // required double azimuth = 4;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 4;
  inline double azimuth() const;
  inline void set_azimuth(double value);

  // required double elevation = 5;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 5;
  inline double elevation() const;
  inline void set_elevation(double value);

  // @@protoc_insertion_point(class_scope:kama.protocol.AngleChannelState)
 private:
  inline void set_has_time_mode();
  inline void clear_has_time_mode();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_tracking_mode();
  inline void clear_has_tracking_mode();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* time_;
  ::google::protobuf::int32 time_mode_;
  ::google::protobuf::int32 tracking_mode_;
  double azimuth_;
  double elevation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static AngleChannelState* default_instance_;
};
// -------------------------------------------------------------------

class StateGettingReq : public ::google::protobuf::Message {
 public:
  StateGettingReq();
  virtual ~StateGettingReq();

  StateGettingReq(const StateGettingReq& from);

  inline StateGettingReq& operator=(const StateGettingReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateGettingReq& default_instance();

  void Swap(StateGettingReq* other);

  // implements Message ----------------------------------------------

  StateGettingReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StateGettingReq& from);
  void MergeFrom(const StateGettingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kama.protocol.StateGettingReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static StateGettingReq* default_instance_;
};
// -------------------------------------------------------------------

class StateGettingAck : public ::google::protobuf::Message {
 public:
  StateGettingAck();
  virtual ~StateGettingAck();

  StateGettingAck(const StateGettingAck& from);

  inline StateGettingAck& operator=(const StateGettingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateGettingAck& default_instance();

  void Swap(StateGettingAck* other);

  // implements Message ----------------------------------------------

  StateGettingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StateGettingAck& from);
  void MergeFrom(const StateGettingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool registration_device_connected = 1;
  inline bool has_registration_device_connected() const;
  inline void clear_registration_device_connected();
  static const int kRegistrationDeviceConnectedFieldNumber = 1;
  inline bool registration_device_connected() const;
  inline void set_registration_device_connected(bool value);

  // required bool pointing_device_connected = 2;
  inline bool has_pointing_device_connected() const;
  inline void clear_pointing_device_connected();
  static const int kPointingDeviceConnectedFieldNumber = 2;
  inline bool pointing_device_connected() const;
  inline void set_pointing_device_connected(bool value);

  // @@protoc_insertion_point(class_scope:kama.protocol.StateGettingAck)
 private:
  inline void set_has_registration_device_connected();
  inline void clear_has_registration_device_connected();
  inline void set_has_pointing_device_connected();
  inline void clear_has_pointing_device_connected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool registration_device_connected_;
  bool pointing_device_connected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static StateGettingAck* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kama.protocol.Ping)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Pong : public ::google::protobuf::Message {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong& default_instance();

  void Swap(Pong* other);

  // implements Message ----------------------------------------------

  Pong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kama.protocol.Pong)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static Pong* default_instance_;
};
// -------------------------------------------------------------------

class PointingTableSettingReq : public ::google::protobuf::Message {
 public:
  PointingTableSettingReq();
  virtual ~PointingTableSettingReq();

  PointingTableSettingReq(const PointingTableSettingReq& from);

  inline PointingTableSettingReq& operator=(const PointingTableSettingReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointingTableSettingReq& default_instance();

  void Swap(PointingTableSettingReq* other);

  // implements Message ----------------------------------------------

  PointingTableSettingReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointingTableSettingReq& from);
  void MergeFrom(const PointingTableSettingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .kama.protocol.PointingTable table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::kama::protocol::PointingTable& table() const;
  inline ::kama::protocol::PointingTable* mutable_table();
  inline ::kama::protocol::PointingTable* release_table();
  inline void set_allocated_table(::kama::protocol::PointingTable* table);

  // @@protoc_insertion_point(class_scope:kama.protocol.PointingTableSettingReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::kama::protocol::PointingTable* table_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static PointingTableSettingReq* default_instance_;
};
// -------------------------------------------------------------------

class PointingTableSettingAck : public ::google::protobuf::Message {
 public:
  PointingTableSettingAck();
  virtual ~PointingTableSettingAck();

  PointingTableSettingAck(const PointingTableSettingAck& from);

  inline PointingTableSettingAck& operator=(const PointingTableSettingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointingTableSettingAck& default_instance();

  void Swap(PointingTableSettingAck* other);

  // implements Message ----------------------------------------------

  PointingTableSettingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointingTableSettingAck& from);
  void MergeFrom(const PointingTableSettingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kama.protocol.PointingTableSettingAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static PointingTableSettingAck* default_instance_;
};
// -------------------------------------------------------------------

class PointingTableSettingNak : public ::google::protobuf::Message {
 public:
  PointingTableSettingNak();
  virtual ~PointingTableSettingNak();

  PointingTableSettingNak(const PointingTableSettingNak& from);

  inline PointingTableSettingNak& operator=(const PointingTableSettingNak& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointingTableSettingNak& default_instance();

  void Swap(PointingTableSettingNak* other);

  // implements Message ----------------------------------------------

  PointingTableSettingNak* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointingTableSettingNak& from);
  void MergeFrom(const PointingTableSettingNak& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error_message = 1;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 1;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:kama.protocol.PointingTableSettingNak)
 private:
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static PointingTableSettingNak* default_instance_;
};
// -------------------------------------------------------------------

class PointingTableGettingReq : public ::google::protobuf::Message {
 public:
  PointingTableGettingReq();
  virtual ~PointingTableGettingReq();

  PointingTableGettingReq(const PointingTableGettingReq& from);

  inline PointingTableGettingReq& operator=(const PointingTableGettingReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointingTableGettingReq& default_instance();

  void Swap(PointingTableGettingReq* other);

  // implements Message ----------------------------------------------

  PointingTableGettingReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointingTableGettingReq& from);
  void MergeFrom(const PointingTableGettingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kama.protocol.PointingTableGettingReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static PointingTableGettingReq* default_instance_;
};
// -------------------------------------------------------------------

class PointingTableGettingAck : public ::google::protobuf::Message {
 public:
  PointingTableGettingAck();
  virtual ~PointingTableGettingAck();

  PointingTableGettingAck(const PointingTableGettingAck& from);

  inline PointingTableGettingAck& operator=(const PointingTableGettingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointingTableGettingAck& default_instance();

  void Swap(PointingTableGettingAck* other);

  // implements Message ----------------------------------------------

  PointingTableGettingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointingTableGettingAck& from);
  void MergeFrom(const PointingTableGettingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .kama.protocol.PointingTable table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::kama::protocol::PointingTable& table() const;
  inline ::kama::protocol::PointingTable* mutable_table();
  inline ::kama::protocol::PointingTable* release_table();
  inline void set_allocated_table(::kama::protocol::PointingTable* table);

  // @@protoc_insertion_point(class_scope:kama.protocol.PointingTableGettingAck)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::kama::protocol::PointingTable* table_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static PointingTableGettingAck* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationTableSettingReq : public ::google::protobuf::Message {
 public:
  CalibrationTableSettingReq();
  virtual ~CalibrationTableSettingReq();

  CalibrationTableSettingReq(const CalibrationTableSettingReq& from);

  inline CalibrationTableSettingReq& operator=(const CalibrationTableSettingReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationTableSettingReq& default_instance();

  void Swap(CalibrationTableSettingReq* other);

  // implements Message ----------------------------------------------

  CalibrationTableSettingReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationTableSettingReq& from);
  void MergeFrom(const CalibrationTableSettingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .kama.protocol.CalibrationTable table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::kama::protocol::CalibrationTable& table() const;
  inline ::kama::protocol::CalibrationTable* mutable_table();
  inline ::kama::protocol::CalibrationTable* release_table();
  inline void set_allocated_table(::kama::protocol::CalibrationTable* table);

  // @@protoc_insertion_point(class_scope:kama.protocol.CalibrationTableSettingReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::kama::protocol::CalibrationTable* table_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static CalibrationTableSettingReq* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationTableSettingAck : public ::google::protobuf::Message {
 public:
  CalibrationTableSettingAck();
  virtual ~CalibrationTableSettingAck();

  CalibrationTableSettingAck(const CalibrationTableSettingAck& from);

  inline CalibrationTableSettingAck& operator=(const CalibrationTableSettingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationTableSettingAck& default_instance();

  void Swap(CalibrationTableSettingAck* other);

  // implements Message ----------------------------------------------

  CalibrationTableSettingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationTableSettingAck& from);
  void MergeFrom(const CalibrationTableSettingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kama.protocol.CalibrationTableSettingAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static CalibrationTableSettingAck* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationTableSettingNak : public ::google::protobuf::Message {
 public:
  CalibrationTableSettingNak();
  virtual ~CalibrationTableSettingNak();

  CalibrationTableSettingNak(const CalibrationTableSettingNak& from);

  inline CalibrationTableSettingNak& operator=(const CalibrationTableSettingNak& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationTableSettingNak& default_instance();

  void Swap(CalibrationTableSettingNak* other);

  // implements Message ----------------------------------------------

  CalibrationTableSettingNak* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationTableSettingNak& from);
  void MergeFrom(const CalibrationTableSettingNak& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error_message = 1;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 1;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:kama.protocol.CalibrationTableSettingNak)
 private:
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static CalibrationTableSettingNak* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationTableGettingReq : public ::google::protobuf::Message {
 public:
  CalibrationTableGettingReq();
  virtual ~CalibrationTableGettingReq();

  CalibrationTableGettingReq(const CalibrationTableGettingReq& from);

  inline CalibrationTableGettingReq& operator=(const CalibrationTableGettingReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationTableGettingReq& default_instance();

  void Swap(CalibrationTableGettingReq* other);

  // implements Message ----------------------------------------------

  CalibrationTableGettingReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationTableGettingReq& from);
  void MergeFrom(const CalibrationTableGettingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kama.protocol.CalibrationTableGettingReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static CalibrationTableGettingReq* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationTableGettingAck : public ::google::protobuf::Message {
 public:
  CalibrationTableGettingAck();
  virtual ~CalibrationTableGettingAck();

  CalibrationTableGettingAck(const CalibrationTableGettingAck& from);

  inline CalibrationTableGettingAck& operator=(const CalibrationTableGettingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationTableGettingAck& default_instance();

  void Swap(CalibrationTableGettingAck* other);

  // implements Message ----------------------------------------------

  CalibrationTableGettingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationTableGettingAck& from);
  void MergeFrom(const CalibrationTableGettingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .kama.protocol.CalibrationTable table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::kama::protocol::CalibrationTable& table() const;
  inline ::kama::protocol::CalibrationTable* mutable_table();
  inline ::kama::protocol::CalibrationTable* release_table();
  inline void set_allocated_table(::kama::protocol::CalibrationTable* table);

  // @@protoc_insertion_point(class_scope:kama.protocol.CalibrationTableGettingAck)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::kama::protocol::CalibrationTable* table_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static CalibrationTableGettingAck* default_instance_;
};
// -------------------------------------------------------------------

class PointingTable : public ::google::protobuf::Message {
 public:
  PointingTable();
  virtual ~PointingTable();

  PointingTable(const PointingTable& from);

  inline PointingTable& operator=(const PointingTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointingTable& default_instance();

  void Swap(PointingTable* other);

  // implements Message ----------------------------------------------

  PointingTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointingTable& from);
  void MergeFrom(const PointingTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string object_type = 2;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 2;
  inline const ::std::string& object_type() const;
  inline void set_object_type(const ::std::string& value);
  inline void set_object_type(const char* value);
  inline void set_object_type(const char* value, size_t size);
  inline ::std::string* mutable_object_type();
  inline ::std::string* release_object_type();
  inline void set_allocated_object_type(::std::string* object_type);

  // repeated .kama.protocol.PointingTableItem item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::kama::protocol::PointingTableItem& item(int index) const;
  inline ::kama::protocol::PointingTableItem* mutable_item(int index);
  inline ::kama::protocol::PointingTableItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::kama::protocol::PointingTableItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::kama::protocol::PointingTableItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:kama.protocol.PointingTable)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_object_type();
  inline void clear_has_object_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* time_;
  ::std::string* object_type_;
  ::google::protobuf::RepeatedPtrField< ::kama::protocol::PointingTableItem > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static PointingTable* default_instance_;
};
// -------------------------------------------------------------------

class PointingTableItem : public ::google::protobuf::Message {
 public:
  PointingTableItem();
  virtual ~PointingTableItem();

  PointingTableItem(const PointingTableItem& from);

  inline PointingTableItem& operator=(const PointingTableItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointingTableItem& default_instance();

  void Swap(PointingTableItem* other);

  // implements Message ----------------------------------------------

  PointingTableItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointingTableItem& from);
  void MergeFrom(const PointingTableItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // required double azimuth = 2;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 2;
  inline double azimuth() const;
  inline void set_azimuth(double value);

  // required double elevation = 3;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 3;
  inline double elevation() const;
  inline void set_elevation(double value);

  // @@protoc_insertion_point(class_scope:kama.protocol.PointingTableItem)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  double azimuth_;
  double elevation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static PointingTableItem* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationTable : public ::google::protobuf::Message {
 public:
  CalibrationTable();
  virtual ~CalibrationTable();

  CalibrationTable(const CalibrationTable& from);

  inline CalibrationTable& operator=(const CalibrationTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationTable& default_instance();

  void Swap(CalibrationTable* other);

  // implements Message ----------------------------------------------

  CalibrationTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationTable& from);
  void MergeFrom(const CalibrationTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kama.protocol.CalibrationTableItem item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::kama::protocol::CalibrationTableItem& item(int index) const;
  inline ::kama::protocol::CalibrationTableItem* mutable_item(int index);
  inline ::kama::protocol::CalibrationTableItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::kama::protocol::CalibrationTableItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::kama::protocol::CalibrationTableItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:kama.protocol.CalibrationTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::kama::protocol::CalibrationTableItem > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static CalibrationTable* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationTableItem : public ::google::protobuf::Message {
 public:
  CalibrationTableItem();
  virtual ~CalibrationTableItem();

  CalibrationTableItem(const CalibrationTableItem& from);

  inline CalibrationTableItem& operator=(const CalibrationTableItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationTableItem& default_instance();

  void Swap(CalibrationTableItem* other);

  // implements Message ----------------------------------------------

  CalibrationTableItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationTableItem& from);
  void MergeFrom(const CalibrationTableItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // required double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:kama.protocol.CalibrationTableItem)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static CalibrationTableItem* default_instance_;
};
// ===================================================================


// ===================================================================

// Envelope

// optional .kama.protocol.AngleChannelState angle_channel_state = 1;
inline bool Envelope::has_angle_channel_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Envelope::set_has_angle_channel_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Envelope::clear_has_angle_channel_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Envelope::clear_angle_channel_state() {
  if (angle_channel_state_ != NULL) angle_channel_state_->::kama::protocol::AngleChannelState::Clear();
  clear_has_angle_channel_state();
}
inline const ::kama::protocol::AngleChannelState& Envelope::angle_channel_state() const {
  return angle_channel_state_ != NULL ? *angle_channel_state_ : *default_instance_->angle_channel_state_;
}
inline ::kama::protocol::AngleChannelState* Envelope::mutable_angle_channel_state() {
  set_has_angle_channel_state();
  if (angle_channel_state_ == NULL) angle_channel_state_ = new ::kama::protocol::AngleChannelState;
  return angle_channel_state_;
}
inline ::kama::protocol::AngleChannelState* Envelope::release_angle_channel_state() {
  clear_has_angle_channel_state();
  ::kama::protocol::AngleChannelState* temp = angle_channel_state_;
  angle_channel_state_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_angle_channel_state(::kama::protocol::AngleChannelState* angle_channel_state) {
  delete angle_channel_state_;
  angle_channel_state_ = angle_channel_state;
  if (angle_channel_state) {
    set_has_angle_channel_state();
  } else {
    clear_has_angle_channel_state();
  }
}

// optional .kama.protocol.StateGettingReq state_getting_req = 2;
inline bool Envelope::has_state_getting_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Envelope::set_has_state_getting_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Envelope::clear_has_state_getting_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Envelope::clear_state_getting_req() {
  if (state_getting_req_ != NULL) state_getting_req_->::kama::protocol::StateGettingReq::Clear();
  clear_has_state_getting_req();
}
inline const ::kama::protocol::StateGettingReq& Envelope::state_getting_req() const {
  return state_getting_req_ != NULL ? *state_getting_req_ : *default_instance_->state_getting_req_;
}
inline ::kama::protocol::StateGettingReq* Envelope::mutable_state_getting_req() {
  set_has_state_getting_req();
  if (state_getting_req_ == NULL) state_getting_req_ = new ::kama::protocol::StateGettingReq;
  return state_getting_req_;
}
inline ::kama::protocol::StateGettingReq* Envelope::release_state_getting_req() {
  clear_has_state_getting_req();
  ::kama::protocol::StateGettingReq* temp = state_getting_req_;
  state_getting_req_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_state_getting_req(::kama::protocol::StateGettingReq* state_getting_req) {
  delete state_getting_req_;
  state_getting_req_ = state_getting_req;
  if (state_getting_req) {
    set_has_state_getting_req();
  } else {
    clear_has_state_getting_req();
  }
}

// optional .kama.protocol.StateGettingAck state_getting_ack = 3;
inline bool Envelope::has_state_getting_ack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Envelope::set_has_state_getting_ack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Envelope::clear_has_state_getting_ack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Envelope::clear_state_getting_ack() {
  if (state_getting_ack_ != NULL) state_getting_ack_->::kama::protocol::StateGettingAck::Clear();
  clear_has_state_getting_ack();
}
inline const ::kama::protocol::StateGettingAck& Envelope::state_getting_ack() const {
  return state_getting_ack_ != NULL ? *state_getting_ack_ : *default_instance_->state_getting_ack_;
}
inline ::kama::protocol::StateGettingAck* Envelope::mutable_state_getting_ack() {
  set_has_state_getting_ack();
  if (state_getting_ack_ == NULL) state_getting_ack_ = new ::kama::protocol::StateGettingAck;
  return state_getting_ack_;
}
inline ::kama::protocol::StateGettingAck* Envelope::release_state_getting_ack() {
  clear_has_state_getting_ack();
  ::kama::protocol::StateGettingAck* temp = state_getting_ack_;
  state_getting_ack_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_state_getting_ack(::kama::protocol::StateGettingAck* state_getting_ack) {
  delete state_getting_ack_;
  state_getting_ack_ = state_getting_ack;
  if (state_getting_ack) {
    set_has_state_getting_ack();
  } else {
    clear_has_state_getting_ack();
  }
}

// optional .kama.protocol.PointingTableSettingReq pointing_table_setting_req = 4;
inline bool Envelope::has_pointing_table_setting_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Envelope::set_has_pointing_table_setting_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Envelope::clear_has_pointing_table_setting_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Envelope::clear_pointing_table_setting_req() {
  if (pointing_table_setting_req_ != NULL) pointing_table_setting_req_->::kama::protocol::PointingTableSettingReq::Clear();
  clear_has_pointing_table_setting_req();
}
inline const ::kama::protocol::PointingTableSettingReq& Envelope::pointing_table_setting_req() const {
  return pointing_table_setting_req_ != NULL ? *pointing_table_setting_req_ : *default_instance_->pointing_table_setting_req_;
}
inline ::kama::protocol::PointingTableSettingReq* Envelope::mutable_pointing_table_setting_req() {
  set_has_pointing_table_setting_req();
  if (pointing_table_setting_req_ == NULL) pointing_table_setting_req_ = new ::kama::protocol::PointingTableSettingReq;
  return pointing_table_setting_req_;
}
inline ::kama::protocol::PointingTableSettingReq* Envelope::release_pointing_table_setting_req() {
  clear_has_pointing_table_setting_req();
  ::kama::protocol::PointingTableSettingReq* temp = pointing_table_setting_req_;
  pointing_table_setting_req_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_pointing_table_setting_req(::kama::protocol::PointingTableSettingReq* pointing_table_setting_req) {
  delete pointing_table_setting_req_;
  pointing_table_setting_req_ = pointing_table_setting_req;
  if (pointing_table_setting_req) {
    set_has_pointing_table_setting_req();
  } else {
    clear_has_pointing_table_setting_req();
  }
}

// optional .kama.protocol.PointingTableSettingAck pointing_table_setting_ack = 5;
inline bool Envelope::has_pointing_table_setting_ack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Envelope::set_has_pointing_table_setting_ack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Envelope::clear_has_pointing_table_setting_ack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Envelope::clear_pointing_table_setting_ack() {
  if (pointing_table_setting_ack_ != NULL) pointing_table_setting_ack_->::kama::protocol::PointingTableSettingAck::Clear();
  clear_has_pointing_table_setting_ack();
}
inline const ::kama::protocol::PointingTableSettingAck& Envelope::pointing_table_setting_ack() const {
  return pointing_table_setting_ack_ != NULL ? *pointing_table_setting_ack_ : *default_instance_->pointing_table_setting_ack_;
}
inline ::kama::protocol::PointingTableSettingAck* Envelope::mutable_pointing_table_setting_ack() {
  set_has_pointing_table_setting_ack();
  if (pointing_table_setting_ack_ == NULL) pointing_table_setting_ack_ = new ::kama::protocol::PointingTableSettingAck;
  return pointing_table_setting_ack_;
}
inline ::kama::protocol::PointingTableSettingAck* Envelope::release_pointing_table_setting_ack() {
  clear_has_pointing_table_setting_ack();
  ::kama::protocol::PointingTableSettingAck* temp = pointing_table_setting_ack_;
  pointing_table_setting_ack_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_pointing_table_setting_ack(::kama::protocol::PointingTableSettingAck* pointing_table_setting_ack) {
  delete pointing_table_setting_ack_;
  pointing_table_setting_ack_ = pointing_table_setting_ack;
  if (pointing_table_setting_ack) {
    set_has_pointing_table_setting_ack();
  } else {
    clear_has_pointing_table_setting_ack();
  }
}

// optional .kama.protocol.PointingTableSettingNak pointing_table_setting_nak = 6;
inline bool Envelope::has_pointing_table_setting_nak() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Envelope::set_has_pointing_table_setting_nak() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Envelope::clear_has_pointing_table_setting_nak() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Envelope::clear_pointing_table_setting_nak() {
  if (pointing_table_setting_nak_ != NULL) pointing_table_setting_nak_->::kama::protocol::PointingTableSettingNak::Clear();
  clear_has_pointing_table_setting_nak();
}
inline const ::kama::protocol::PointingTableSettingNak& Envelope::pointing_table_setting_nak() const {
  return pointing_table_setting_nak_ != NULL ? *pointing_table_setting_nak_ : *default_instance_->pointing_table_setting_nak_;
}
inline ::kama::protocol::PointingTableSettingNak* Envelope::mutable_pointing_table_setting_nak() {
  set_has_pointing_table_setting_nak();
  if (pointing_table_setting_nak_ == NULL) pointing_table_setting_nak_ = new ::kama::protocol::PointingTableSettingNak;
  return pointing_table_setting_nak_;
}
inline ::kama::protocol::PointingTableSettingNak* Envelope::release_pointing_table_setting_nak() {
  clear_has_pointing_table_setting_nak();
  ::kama::protocol::PointingTableSettingNak* temp = pointing_table_setting_nak_;
  pointing_table_setting_nak_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_pointing_table_setting_nak(::kama::protocol::PointingTableSettingNak* pointing_table_setting_nak) {
  delete pointing_table_setting_nak_;
  pointing_table_setting_nak_ = pointing_table_setting_nak;
  if (pointing_table_setting_nak) {
    set_has_pointing_table_setting_nak();
  } else {
    clear_has_pointing_table_setting_nak();
  }
}

// optional .kama.protocol.PointingTableGettingReq pointing_table_getting_req = 7;
inline bool Envelope::has_pointing_table_getting_req() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Envelope::set_has_pointing_table_getting_req() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Envelope::clear_has_pointing_table_getting_req() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Envelope::clear_pointing_table_getting_req() {
  if (pointing_table_getting_req_ != NULL) pointing_table_getting_req_->::kama::protocol::PointingTableGettingReq::Clear();
  clear_has_pointing_table_getting_req();
}
inline const ::kama::protocol::PointingTableGettingReq& Envelope::pointing_table_getting_req() const {
  return pointing_table_getting_req_ != NULL ? *pointing_table_getting_req_ : *default_instance_->pointing_table_getting_req_;
}
inline ::kama::protocol::PointingTableGettingReq* Envelope::mutable_pointing_table_getting_req() {
  set_has_pointing_table_getting_req();
  if (pointing_table_getting_req_ == NULL) pointing_table_getting_req_ = new ::kama::protocol::PointingTableGettingReq;
  return pointing_table_getting_req_;
}
inline ::kama::protocol::PointingTableGettingReq* Envelope::release_pointing_table_getting_req() {
  clear_has_pointing_table_getting_req();
  ::kama::protocol::PointingTableGettingReq* temp = pointing_table_getting_req_;
  pointing_table_getting_req_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_pointing_table_getting_req(::kama::protocol::PointingTableGettingReq* pointing_table_getting_req) {
  delete pointing_table_getting_req_;
  pointing_table_getting_req_ = pointing_table_getting_req;
  if (pointing_table_getting_req) {
    set_has_pointing_table_getting_req();
  } else {
    clear_has_pointing_table_getting_req();
  }
}

// optional .kama.protocol.PointingTableGettingAck pointing_table_getting_ack = 8;
inline bool Envelope::has_pointing_table_getting_ack() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Envelope::set_has_pointing_table_getting_ack() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Envelope::clear_has_pointing_table_getting_ack() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Envelope::clear_pointing_table_getting_ack() {
  if (pointing_table_getting_ack_ != NULL) pointing_table_getting_ack_->::kama::protocol::PointingTableGettingAck::Clear();
  clear_has_pointing_table_getting_ack();
}
inline const ::kama::protocol::PointingTableGettingAck& Envelope::pointing_table_getting_ack() const {
  return pointing_table_getting_ack_ != NULL ? *pointing_table_getting_ack_ : *default_instance_->pointing_table_getting_ack_;
}
inline ::kama::protocol::PointingTableGettingAck* Envelope::mutable_pointing_table_getting_ack() {
  set_has_pointing_table_getting_ack();
  if (pointing_table_getting_ack_ == NULL) pointing_table_getting_ack_ = new ::kama::protocol::PointingTableGettingAck;
  return pointing_table_getting_ack_;
}
inline ::kama::protocol::PointingTableGettingAck* Envelope::release_pointing_table_getting_ack() {
  clear_has_pointing_table_getting_ack();
  ::kama::protocol::PointingTableGettingAck* temp = pointing_table_getting_ack_;
  pointing_table_getting_ack_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_pointing_table_getting_ack(::kama::protocol::PointingTableGettingAck* pointing_table_getting_ack) {
  delete pointing_table_getting_ack_;
  pointing_table_getting_ack_ = pointing_table_getting_ack;
  if (pointing_table_getting_ack) {
    set_has_pointing_table_getting_ack();
  } else {
    clear_has_pointing_table_getting_ack();
  }
}

// optional .kama.protocol.CalibrationTableSettingReq calibration_table_setting_req = 9;
inline bool Envelope::has_calibration_table_setting_req() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Envelope::set_has_calibration_table_setting_req() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Envelope::clear_has_calibration_table_setting_req() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Envelope::clear_calibration_table_setting_req() {
  if (calibration_table_setting_req_ != NULL) calibration_table_setting_req_->::kama::protocol::CalibrationTableSettingReq::Clear();
  clear_has_calibration_table_setting_req();
}
inline const ::kama::protocol::CalibrationTableSettingReq& Envelope::calibration_table_setting_req() const {
  return calibration_table_setting_req_ != NULL ? *calibration_table_setting_req_ : *default_instance_->calibration_table_setting_req_;
}
inline ::kama::protocol::CalibrationTableSettingReq* Envelope::mutable_calibration_table_setting_req() {
  set_has_calibration_table_setting_req();
  if (calibration_table_setting_req_ == NULL) calibration_table_setting_req_ = new ::kama::protocol::CalibrationTableSettingReq;
  return calibration_table_setting_req_;
}
inline ::kama::protocol::CalibrationTableSettingReq* Envelope::release_calibration_table_setting_req() {
  clear_has_calibration_table_setting_req();
  ::kama::protocol::CalibrationTableSettingReq* temp = calibration_table_setting_req_;
  calibration_table_setting_req_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_calibration_table_setting_req(::kama::protocol::CalibrationTableSettingReq* calibration_table_setting_req) {
  delete calibration_table_setting_req_;
  calibration_table_setting_req_ = calibration_table_setting_req;
  if (calibration_table_setting_req) {
    set_has_calibration_table_setting_req();
  } else {
    clear_has_calibration_table_setting_req();
  }
}

// optional .kama.protocol.CalibrationTableSettingAck calibration_table_setting_ack = 10;
inline bool Envelope::has_calibration_table_setting_ack() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Envelope::set_has_calibration_table_setting_ack() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Envelope::clear_has_calibration_table_setting_ack() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Envelope::clear_calibration_table_setting_ack() {
  if (calibration_table_setting_ack_ != NULL) calibration_table_setting_ack_->::kama::protocol::CalibrationTableSettingAck::Clear();
  clear_has_calibration_table_setting_ack();
}
inline const ::kama::protocol::CalibrationTableSettingAck& Envelope::calibration_table_setting_ack() const {
  return calibration_table_setting_ack_ != NULL ? *calibration_table_setting_ack_ : *default_instance_->calibration_table_setting_ack_;
}
inline ::kama::protocol::CalibrationTableSettingAck* Envelope::mutable_calibration_table_setting_ack() {
  set_has_calibration_table_setting_ack();
  if (calibration_table_setting_ack_ == NULL) calibration_table_setting_ack_ = new ::kama::protocol::CalibrationTableSettingAck;
  return calibration_table_setting_ack_;
}
inline ::kama::protocol::CalibrationTableSettingAck* Envelope::release_calibration_table_setting_ack() {
  clear_has_calibration_table_setting_ack();
  ::kama::protocol::CalibrationTableSettingAck* temp = calibration_table_setting_ack_;
  calibration_table_setting_ack_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_calibration_table_setting_ack(::kama::protocol::CalibrationTableSettingAck* calibration_table_setting_ack) {
  delete calibration_table_setting_ack_;
  calibration_table_setting_ack_ = calibration_table_setting_ack;
  if (calibration_table_setting_ack) {
    set_has_calibration_table_setting_ack();
  } else {
    clear_has_calibration_table_setting_ack();
  }
}

// optional .kama.protocol.CalibrationTableSettingNak calibration_table_setting_nak = 11;
inline bool Envelope::has_calibration_table_setting_nak() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Envelope::set_has_calibration_table_setting_nak() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Envelope::clear_has_calibration_table_setting_nak() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Envelope::clear_calibration_table_setting_nak() {
  if (calibration_table_setting_nak_ != NULL) calibration_table_setting_nak_->::kama::protocol::CalibrationTableSettingNak::Clear();
  clear_has_calibration_table_setting_nak();
}
inline const ::kama::protocol::CalibrationTableSettingNak& Envelope::calibration_table_setting_nak() const {
  return calibration_table_setting_nak_ != NULL ? *calibration_table_setting_nak_ : *default_instance_->calibration_table_setting_nak_;
}
inline ::kama::protocol::CalibrationTableSettingNak* Envelope::mutable_calibration_table_setting_nak() {
  set_has_calibration_table_setting_nak();
  if (calibration_table_setting_nak_ == NULL) calibration_table_setting_nak_ = new ::kama::protocol::CalibrationTableSettingNak;
  return calibration_table_setting_nak_;
}
inline ::kama::protocol::CalibrationTableSettingNak* Envelope::release_calibration_table_setting_nak() {
  clear_has_calibration_table_setting_nak();
  ::kama::protocol::CalibrationTableSettingNak* temp = calibration_table_setting_nak_;
  calibration_table_setting_nak_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_calibration_table_setting_nak(::kama::protocol::CalibrationTableSettingNak* calibration_table_setting_nak) {
  delete calibration_table_setting_nak_;
  calibration_table_setting_nak_ = calibration_table_setting_nak;
  if (calibration_table_setting_nak) {
    set_has_calibration_table_setting_nak();
  } else {
    clear_has_calibration_table_setting_nak();
  }
}

// optional .kama.protocol.CalibrationTableGettingReq calibration_table_getting_req = 12;
inline bool Envelope::has_calibration_table_getting_req() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Envelope::set_has_calibration_table_getting_req() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Envelope::clear_has_calibration_table_getting_req() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Envelope::clear_calibration_table_getting_req() {
  if (calibration_table_getting_req_ != NULL) calibration_table_getting_req_->::kama::protocol::CalibrationTableGettingReq::Clear();
  clear_has_calibration_table_getting_req();
}
inline const ::kama::protocol::CalibrationTableGettingReq& Envelope::calibration_table_getting_req() const {
  return calibration_table_getting_req_ != NULL ? *calibration_table_getting_req_ : *default_instance_->calibration_table_getting_req_;
}
inline ::kama::protocol::CalibrationTableGettingReq* Envelope::mutable_calibration_table_getting_req() {
  set_has_calibration_table_getting_req();
  if (calibration_table_getting_req_ == NULL) calibration_table_getting_req_ = new ::kama::protocol::CalibrationTableGettingReq;
  return calibration_table_getting_req_;
}
inline ::kama::protocol::CalibrationTableGettingReq* Envelope::release_calibration_table_getting_req() {
  clear_has_calibration_table_getting_req();
  ::kama::protocol::CalibrationTableGettingReq* temp = calibration_table_getting_req_;
  calibration_table_getting_req_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_calibration_table_getting_req(::kama::protocol::CalibrationTableGettingReq* calibration_table_getting_req) {
  delete calibration_table_getting_req_;
  calibration_table_getting_req_ = calibration_table_getting_req;
  if (calibration_table_getting_req) {
    set_has_calibration_table_getting_req();
  } else {
    clear_has_calibration_table_getting_req();
  }
}

// optional .kama.protocol.CalibrationTableGettingAck calibration_table_getting_ack = 13;
inline bool Envelope::has_calibration_table_getting_ack() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Envelope::set_has_calibration_table_getting_ack() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Envelope::clear_has_calibration_table_getting_ack() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Envelope::clear_calibration_table_getting_ack() {
  if (calibration_table_getting_ack_ != NULL) calibration_table_getting_ack_->::kama::protocol::CalibrationTableGettingAck::Clear();
  clear_has_calibration_table_getting_ack();
}
inline const ::kama::protocol::CalibrationTableGettingAck& Envelope::calibration_table_getting_ack() const {
  return calibration_table_getting_ack_ != NULL ? *calibration_table_getting_ack_ : *default_instance_->calibration_table_getting_ack_;
}
inline ::kama::protocol::CalibrationTableGettingAck* Envelope::mutable_calibration_table_getting_ack() {
  set_has_calibration_table_getting_ack();
  if (calibration_table_getting_ack_ == NULL) calibration_table_getting_ack_ = new ::kama::protocol::CalibrationTableGettingAck;
  return calibration_table_getting_ack_;
}
inline ::kama::protocol::CalibrationTableGettingAck* Envelope::release_calibration_table_getting_ack() {
  clear_has_calibration_table_getting_ack();
  ::kama::protocol::CalibrationTableGettingAck* temp = calibration_table_getting_ack_;
  calibration_table_getting_ack_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_calibration_table_getting_ack(::kama::protocol::CalibrationTableGettingAck* calibration_table_getting_ack) {
  delete calibration_table_getting_ack_;
  calibration_table_getting_ack_ = calibration_table_getting_ack;
  if (calibration_table_getting_ack) {
    set_has_calibration_table_getting_ack();
  } else {
    clear_has_calibration_table_getting_ack();
  }
}

// -------------------------------------------------------------------

// AngleChannelState

// required int32 time_mode = 1;
inline bool AngleChannelState::has_time_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AngleChannelState::set_has_time_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AngleChannelState::clear_has_time_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AngleChannelState::clear_time_mode() {
  time_mode_ = 0;
  clear_has_time_mode();
}
inline ::google::protobuf::int32 AngleChannelState::time_mode() const {
  return time_mode_;
}
inline void AngleChannelState::set_time_mode(::google::protobuf::int32 value) {
  set_has_time_mode();
  time_mode_ = value;
}

// required string time = 2;
inline bool AngleChannelState::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AngleChannelState::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AngleChannelState::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AngleChannelState::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& AngleChannelState::time() const {
  return *time_;
}
inline void AngleChannelState::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void AngleChannelState::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void AngleChannelState::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AngleChannelState::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* AngleChannelState::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AngleChannelState::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 tracking_mode = 3;
inline bool AngleChannelState::has_tracking_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AngleChannelState::set_has_tracking_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AngleChannelState::clear_has_tracking_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AngleChannelState::clear_tracking_mode() {
  tracking_mode_ = 0;
  clear_has_tracking_mode();
}
inline ::google::protobuf::int32 AngleChannelState::tracking_mode() const {
  return tracking_mode_;
}
inline void AngleChannelState::set_tracking_mode(::google::protobuf::int32 value) {
  set_has_tracking_mode();
  tracking_mode_ = value;
}

// required double azimuth = 4;
inline bool AngleChannelState::has_azimuth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AngleChannelState::set_has_azimuth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AngleChannelState::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AngleChannelState::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline double AngleChannelState::azimuth() const {
  return azimuth_;
}
inline void AngleChannelState::set_azimuth(double value) {
  set_has_azimuth();
  azimuth_ = value;
}

// required double elevation = 5;
inline bool AngleChannelState::has_elevation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AngleChannelState::set_has_elevation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AngleChannelState::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AngleChannelState::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline double AngleChannelState::elevation() const {
  return elevation_;
}
inline void AngleChannelState::set_elevation(double value) {
  set_has_elevation();
  elevation_ = value;
}

// -------------------------------------------------------------------

// StateGettingReq

// -------------------------------------------------------------------

// StateGettingAck

// required bool registration_device_connected = 1;
inline bool StateGettingAck::has_registration_device_connected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateGettingAck::set_has_registration_device_connected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateGettingAck::clear_has_registration_device_connected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateGettingAck::clear_registration_device_connected() {
  registration_device_connected_ = false;
  clear_has_registration_device_connected();
}
inline bool StateGettingAck::registration_device_connected() const {
  return registration_device_connected_;
}
inline void StateGettingAck::set_registration_device_connected(bool value) {
  set_has_registration_device_connected();
  registration_device_connected_ = value;
}

// required bool pointing_device_connected = 2;
inline bool StateGettingAck::has_pointing_device_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateGettingAck::set_has_pointing_device_connected() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateGettingAck::clear_has_pointing_device_connected() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateGettingAck::clear_pointing_device_connected() {
  pointing_device_connected_ = false;
  clear_has_pointing_device_connected();
}
inline bool StateGettingAck::pointing_device_connected() const {
  return pointing_device_connected_;
}
inline void StateGettingAck::set_pointing_device_connected(bool value) {
  set_has_pointing_device_connected();
  pointing_device_connected_ = value;
}

// -------------------------------------------------------------------

// Ping

// -------------------------------------------------------------------

// Pong

// -------------------------------------------------------------------

// PointingTableSettingReq

// required .kama.protocol.PointingTable table = 1;
inline bool PointingTableSettingReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointingTableSettingReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointingTableSettingReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointingTableSettingReq::clear_table() {
  if (table_ != NULL) table_->::kama::protocol::PointingTable::Clear();
  clear_has_table();
}
inline const ::kama::protocol::PointingTable& PointingTableSettingReq::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::kama::protocol::PointingTable* PointingTableSettingReq::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::kama::protocol::PointingTable;
  return table_;
}
inline ::kama::protocol::PointingTable* PointingTableSettingReq::release_table() {
  clear_has_table();
  ::kama::protocol::PointingTable* temp = table_;
  table_ = NULL;
  return temp;
}
inline void PointingTableSettingReq::set_allocated_table(::kama::protocol::PointingTable* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
}

// -------------------------------------------------------------------

// PointingTableSettingAck

// -------------------------------------------------------------------

// PointingTableSettingNak

// required string error_message = 1;
inline bool PointingTableSettingNak::has_error_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointingTableSettingNak::set_has_error_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointingTableSettingNak::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointingTableSettingNak::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& PointingTableSettingNak::error_message() const {
  return *error_message_;
}
inline void PointingTableSettingNak::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void PointingTableSettingNak::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void PointingTableSettingNak::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointingTableSettingNak::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* PointingTableSettingNak::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointingTableSettingNak::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PointingTableGettingReq

// -------------------------------------------------------------------

// PointingTableGettingAck

// required .kama.protocol.PointingTable table = 1;
inline bool PointingTableGettingAck::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointingTableGettingAck::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointingTableGettingAck::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointingTableGettingAck::clear_table() {
  if (table_ != NULL) table_->::kama::protocol::PointingTable::Clear();
  clear_has_table();
}
inline const ::kama::protocol::PointingTable& PointingTableGettingAck::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::kama::protocol::PointingTable* PointingTableGettingAck::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::kama::protocol::PointingTable;
  return table_;
}
inline ::kama::protocol::PointingTable* PointingTableGettingAck::release_table() {
  clear_has_table();
  ::kama::protocol::PointingTable* temp = table_;
  table_ = NULL;
  return temp;
}
inline void PointingTableGettingAck::set_allocated_table(::kama::protocol::PointingTable* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
}

// -------------------------------------------------------------------

// CalibrationTableSettingReq

// required .kama.protocol.CalibrationTable table = 1;
inline bool CalibrationTableSettingReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationTableSettingReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationTableSettingReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationTableSettingReq::clear_table() {
  if (table_ != NULL) table_->::kama::protocol::CalibrationTable::Clear();
  clear_has_table();
}
inline const ::kama::protocol::CalibrationTable& CalibrationTableSettingReq::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::kama::protocol::CalibrationTable* CalibrationTableSettingReq::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::kama::protocol::CalibrationTable;
  return table_;
}
inline ::kama::protocol::CalibrationTable* CalibrationTableSettingReq::release_table() {
  clear_has_table();
  ::kama::protocol::CalibrationTable* temp = table_;
  table_ = NULL;
  return temp;
}
inline void CalibrationTableSettingReq::set_allocated_table(::kama::protocol::CalibrationTable* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
}

// -------------------------------------------------------------------

// CalibrationTableSettingAck

// -------------------------------------------------------------------

// CalibrationTableSettingNak

// required string error_message = 1;
inline bool CalibrationTableSettingNak::has_error_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationTableSettingNak::set_has_error_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationTableSettingNak::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationTableSettingNak::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& CalibrationTableSettingNak::error_message() const {
  return *error_message_;
}
inline void CalibrationTableSettingNak::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void CalibrationTableSettingNak::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void CalibrationTableSettingNak::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CalibrationTableSettingNak::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* CalibrationTableSettingNak::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CalibrationTableSettingNak::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CalibrationTableGettingReq

// -------------------------------------------------------------------

// CalibrationTableGettingAck

// required .kama.protocol.CalibrationTable table = 1;
inline bool CalibrationTableGettingAck::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationTableGettingAck::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationTableGettingAck::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationTableGettingAck::clear_table() {
  if (table_ != NULL) table_->::kama::protocol::CalibrationTable::Clear();
  clear_has_table();
}
inline const ::kama::protocol::CalibrationTable& CalibrationTableGettingAck::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::kama::protocol::CalibrationTable* CalibrationTableGettingAck::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::kama::protocol::CalibrationTable;
  return table_;
}
inline ::kama::protocol::CalibrationTable* CalibrationTableGettingAck::release_table() {
  clear_has_table();
  ::kama::protocol::CalibrationTable* temp = table_;
  table_ = NULL;
  return temp;
}
inline void CalibrationTableGettingAck::set_allocated_table(::kama::protocol::CalibrationTable* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
}

// -------------------------------------------------------------------

// PointingTable

// optional string time = 1;
inline bool PointingTable::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointingTable::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointingTable::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointingTable::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& PointingTable::time() const {
  return *time_;
}
inline void PointingTable::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void PointingTable::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void PointingTable::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointingTable::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* PointingTable::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointingTable::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string object_type = 2;
inline bool PointingTable::has_object_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointingTable::set_has_object_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointingTable::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointingTable::clear_object_type() {
  if (object_type_ != &::google::protobuf::internal::kEmptyString) {
    object_type_->clear();
  }
  clear_has_object_type();
}
inline const ::std::string& PointingTable::object_type() const {
  return *object_type_;
}
inline void PointingTable::set_object_type(const ::std::string& value) {
  set_has_object_type();
  if (object_type_ == &::google::protobuf::internal::kEmptyString) {
    object_type_ = new ::std::string;
  }
  object_type_->assign(value);
}
inline void PointingTable::set_object_type(const char* value) {
  set_has_object_type();
  if (object_type_ == &::google::protobuf::internal::kEmptyString) {
    object_type_ = new ::std::string;
  }
  object_type_->assign(value);
}
inline void PointingTable::set_object_type(const char* value, size_t size) {
  set_has_object_type();
  if (object_type_ == &::google::protobuf::internal::kEmptyString) {
    object_type_ = new ::std::string;
  }
  object_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PointingTable::mutable_object_type() {
  set_has_object_type();
  if (object_type_ == &::google::protobuf::internal::kEmptyString) {
    object_type_ = new ::std::string;
  }
  return object_type_;
}
inline ::std::string* PointingTable::release_object_type() {
  clear_has_object_type();
  if (object_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_type_;
    object_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PointingTable::set_allocated_object_type(::std::string* object_type) {
  if (object_type_ != &::google::protobuf::internal::kEmptyString) {
    delete object_type_;
  }
  if (object_type) {
    set_has_object_type();
    object_type_ = object_type;
  } else {
    clear_has_object_type();
    object_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .kama.protocol.PointingTableItem item = 3;
inline int PointingTable::item_size() const {
  return item_.size();
}
inline void PointingTable::clear_item() {
  item_.Clear();
}
inline const ::kama::protocol::PointingTableItem& PointingTable::item(int index) const {
  return item_.Get(index);
}
inline ::kama::protocol::PointingTableItem* PointingTable::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::kama::protocol::PointingTableItem* PointingTable::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kama::protocol::PointingTableItem >&
PointingTable::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::kama::protocol::PointingTableItem >*
PointingTable::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// PointingTableItem

// required double time = 1;
inline bool PointingTableItem::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointingTableItem::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointingTableItem::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointingTableItem::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double PointingTableItem::time() const {
  return time_;
}
inline void PointingTableItem::set_time(double value) {
  set_has_time();
  time_ = value;
}

// required double azimuth = 2;
inline bool PointingTableItem::has_azimuth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointingTableItem::set_has_azimuth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointingTableItem::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointingTableItem::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline double PointingTableItem::azimuth() const {
  return azimuth_;
}
inline void PointingTableItem::set_azimuth(double value) {
  set_has_azimuth();
  azimuth_ = value;
}

// required double elevation = 3;
inline bool PointingTableItem::has_elevation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointingTableItem::set_has_elevation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointingTableItem::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointingTableItem::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline double PointingTableItem::elevation() const {
  return elevation_;
}
inline void PointingTableItem::set_elevation(double value) {
  set_has_elevation();
  elevation_ = value;
}

// -------------------------------------------------------------------

// CalibrationTable

// repeated .kama.protocol.CalibrationTableItem item = 3;
inline int CalibrationTable::item_size() const {
  return item_.size();
}
inline void CalibrationTable::clear_item() {
  item_.Clear();
}
inline const ::kama::protocol::CalibrationTableItem& CalibrationTable::item(int index) const {
  return item_.Get(index);
}
inline ::kama::protocol::CalibrationTableItem* CalibrationTable::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::kama::protocol::CalibrationTableItem* CalibrationTable::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kama::protocol::CalibrationTableItem >&
CalibrationTable::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::kama::protocol::CalibrationTableItem >*
CalibrationTable::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// CalibrationTableItem

// required double time = 1;
inline bool CalibrationTableItem::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationTableItem::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationTableItem::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationTableItem::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double CalibrationTableItem::time() const {
  return time_;
}
inline void CalibrationTableItem::set_time(double value) {
  set_has_time();
  time_ = value;
}

// required double value = 2;
inline bool CalibrationTableItem::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CalibrationTableItem::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CalibrationTableItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CalibrationTableItem::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double CalibrationTableItem::value() const {
  return value_;
}
inline void CalibrationTableItem::set_value(double value) {
  set_has_value();
  value_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace kama

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kama_2eproto__INCLUDED
